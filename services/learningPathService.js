// services/learningPathService.js
import { getCurrentUser } from './authService.js';
const db = firebase.firestore();

/**
 * Saves a newly generated learning path to Firestore.
 * @param {object} pathData - The learning path object generated by the AI.
 * @returns {Promise<string>} The ID of the newly created document.
 */
export async function saveLearningPath(pathData) {
    const user = getCurrentUser();
    if (!user) throw new Error("User not authenticated.");

    try {
        const pathsCollection = db.collection('users').doc(user.uid).collection('learningPaths');
        const docRef = await pathsCollection.add({
            ...pathData,
            currentStep: 0,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        return docRef.id;
    } catch (error) {
        console.error("Error saving learning path:", error);
        window.showToast("Failed to save your new learning path.", "error");
        throw error;
    }
}

/**
 * Fetches all active learning paths for the current user.
 * @returns {Promise<Array<object>>} An array of learning path objects with their IDs.
 */
export async function getActiveLearningPaths() {
    const user = getCurrentUser();
    if (!user) return [];

    try {
        const pathsCollection = db.collection('users').doc(user.uid).collection('learningPaths');
        const snapshot = await pathsCollection.orderBy('createdAt', 'desc').get();
        return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    } catch (error) {
        console.error("Error fetching learning paths:", error);
        window.showToast("Could not load your learning paths.", "error");
        return [];
    }
}

/**
 * Fetches a single learning path by its ID.
 * @param {string} pathId - The ID of the learning path.
 * @returns {Promise<object|null>} The learning path data or null if not found.
 */
export async function getLearningPathById(pathId) {
    const user = getCurrentUser();
    if (!user) return null;

    try {
        const pathDocRef = db.collection('users').doc(user.uid).collection('learningPaths').doc(pathId);
        const doc = await pathDocRef.get();
        if (doc.exists) {
            return { id: doc.id, ...doc.data() };
        }
        return null;
    } catch (error) {
        console.error("Error fetching learning path by ID:", error);
        window.showToast("Could not load the learning path details.", "error");
        return null;
    }
}

/**
 * Updates the progress of a learning path.
 * @param {string} pathId - The ID of the path to update.
 * @param {number} newStep - The index of the next step to be unlocked.
 * @returns {Promise<void>}
 */
export async function updateLearningPathProgress(pathId, newStep) {
    const user = getCurrentUser();
    if (!user) return;

    try {
        const pathDocRef = db.collection('users').doc(user.uid).collection('learningPaths').doc(pathId);
        await pathDocRef.update({ currentStep: newStep });
    } catch (error) {
        console.error("Error updating learning path progress:", error);
        window.showToast("Failed to update your path progress.", "error");
        throw error;
    }
}
